CASE 1: Parent Writes, Child Reads
#include <stdio.h>
#include <unistd.h>
#include <string.h>
int main() {
int fd[2];
pipe(fd); // create pipe
pid_t pid = fork();
if (pid > 0) { // Parent
close(fd[0]); // Close read end
char msg[] = "Hello from parent!";
write(fd[1], msg, strlen(msg) + 1);
close(fd[1]);
} else if (pid == 0) { // Child
close(fd[1]); // Close write end
char buffer[100];
read(fd[0], buffer, sizeof(buffer));
printf("Child received: %s\n", buffer);
close(fd[0]);
}
return 0;
}


Compile and Run
gcc filename.c -o filename
./filename



CASE 2: Child Writes, Parent Reads
#include <stdio.h>
#include <unistd.h>
#include <string.h>
int main() {
int fd[2];
pipe(fd);
pid_t pid = fork();
if (pid == 0) { // Child
close(fd[0]);
char msg[] = "Hello from child!";
write(fd[1], msg, strlen(msg) + 1);
close(fd[1]);
} else { // Parent
close(fd[1]);
char buffer[100];
read(fd[0], buffer, sizeof(buffer));
printf("Parent received: %s\n", buffer);
close(fd[0]);
}
return 0;
}

Compile and Run
gcc filename.c -o filename
./filename


CASE 3: Bidirectional Communication Using Two Pipes
You need two pipes, since pipe() is unidirectional.
#include <stdio.h>
#include <unistd.h>
#include <string.h>
int main() {
int pipe1[2], pipe2[2];
pipe(pipe1); // Parent -> Child
pipe(pipe2); // Child -> Parent
pid_t pid = fork();
if (pid > 0) { // Parent
close(pipe1[0]); // Close read end of pipe1
close(pipe2[1]); // Close write end of pipe2
char msg[] = "Hello from parent!";
write(pipe1[1], msg, strlen(msg) + 1);
close(pipe1[1]);
char buffer[100];
read(pipe2[0], buffer, sizeof(buffer));
printf("Parent received: %s\n", buffer);
close(pipe2[0]);
} else { // Child
close(pipe1[1]); // Close write end of pipe1
close(pipe2[0]); // Close read end of pipe2
char buffer[100];
read(pipe1[0], buffer, sizeof(buffer));
printf("Child received: %s\n", buffer);
close(pipe1[0]);
char reply[] = "Hi Parent, message received!";
write(pipe2[1], reply, strlen(reply) + 1);
close(pipe2[1]);
}
return 0;
}


Compile and Run
gcc filename.c -o filename
./filename


Case4
#include <stdio.h>
#include <unistd.h>
#include <string.h>
#include <stdlib.h>
#include <sys/wait.h>
int main() {
int fd[2];
char buffer[200];
pipe(fd);
pid_t pid = fork();
if (pid == 0) {
// Child: write after parent
sleep(1);
close(fd[0]); // Close read end
write(fd[1], "Child message.\n", 15);
close(fd[1]);
} else {
// Parent
close(fd[0]); // Close read end
write(fd[1], "Parent message.\n", 16);
wait(NULL); // Wait for child to finish
close(fd[1]);
// Reopen pipe to read (simulate shared read buffer)
pipe(fd); // new pipe to read from
pid_t reader = fork();
if (reader == 0) {
// Reader
close(fd[1]);
int n = read(fd[0], buffer, sizeof(buffer)-1);
buffer[n] = '\0';
printf("Combined messages:\n%s", buffer);
close(fd[0]);
exit(0);
} else {
close(fd[0]);
close(fd[1]);
wait(NULL);
}
}
return 0;
}

Compile and Run
gcc filename.c -o filename
./filename